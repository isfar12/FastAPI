# Tutorial: Connecting FastAPI to MySQL Database

## Overview

This tutorial teaches you how to connect a FastAPI application to a MySQL database instead of SQLite. The code structure is almost identical to the SQLite version, but with important differences in the connection URL and setup. We'll learn how to use environment variables for secure configuration and connect to a production-grade database.

## Project Structure

```
4. Connect to MySQL/
├── database_setup.py  # Database configuration with MySQL
└── main.py           # FastAPI application (identical to SQLite version)
```

---

## Prerequisites

Before starting, you need:

1. **MySQL Server** installed and running
2. **Python packages**: `pip install fastapi uvicorn sqlmodel pymysql cryptography`
   - `pymysql`: Python MySQL driver
   - `cryptography`: Required by pymysql for secure connections

---

## Step 1: Database Setup (`database_setup.py`)

Let's set up the MySQL connection. The model definition is the same, but the connection configuration is different.

```python
import os
from typing import Optional

from sqlmodel import Field, Session, SQLModel, create_engine
```

**Line-by-line explanation:**

- `import os`: Needed to read environment variables
  - Environment variables keep sensitive data (passwords) out of your code
- `from typing import Optional`: For nullable fields
- `from sqlmodel import Field, Session, SQLModel, create_engine`: SQLModel components
  - Note: We import `Session` here even though we use it in main.py

### Define the Item Model

```python
class Item(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str
    price: float
    is_offer: bool = False
```

**This is identical to the SQLite version:**

- `SQLModel` with `table=True` creates a database table
- `id` is auto-generated by the database (MySQL's AUTO_INCREMENT)
- `name`, `price`, and `is_offer` are the data fields

### Configure MySQL Connection with Environment Variables

```python
# Configure MySQL connection (change defaults or use environment variables)
MYSQL_USER = os.getenv("MYSQL_USER", "root")
MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD", "")
MYSQL_HOST = os.getenv("MYSQL_HOST", "localhost")
MYSQL_PORT = os.getenv("MYSQL_PORT", "3306")
MYSQL_DB = os.getenv("MYSQL_DB", "fastapi_db")
```

**Line-by-line explanation:**

- `os.getenv("MYSQL_USER", "root")`: Read environment variable
  - **First parameter**: The environment variable name to look for
  - **Second parameter**: Default value if the variable doesn't exist
  - This allows you to customize settings without changing code

**How each variable works:**

- `MYSQL_USER`: The MySQL username (default: "root")
  - In production, create a dedicated user instead of using root
- `MYSQL_PASSWORD`: The user's password (default: empty string)
  - **IMPORTANT**: Never hardcode passwords in production!
  - Set via environment variable: `export MYSQL_PASSWORD="your_password"`
- `MYSQL_HOST`: Where MySQL server is running (default: "localhost")
  - "localhost" means the same machine as your FastAPI app
  - Could be "192.168.1.100" or "mysql.example.com" for remote servers
- `MYSQL_PORT`: MySQL port number (default: "3306")
  - 3306 is MySQL's standard port
- `MYSQL_DB`: The database name to use (default: "fastapi_db")
  - This database must already exist in MySQL
  - Create it first: `CREATE DATABASE fastapi_db;`

**Why use environment variables?**

1. **Security**: Passwords aren't in your code or version control
2. **Flexibility**: Different settings for dev/staging/production
3. **Best Practice**: Industry standard for configuration management

### Build the MySQL Connection URL

```python
mysql_url = (
    f"mysql+pymysql://{MYSQL_USER}:{MYSQL_PASSWORD}@{MYSQL_HOST}:{MYSQL_PORT}/{MYSQL_DB}"
)
```

**Line-by-line explanation:**

- `mysql_url`: The complete connection string for MySQL
- Format breakdown: `mysql+pymysql://USER:PASSWORD@HOST:PORT/DATABASE`
  - `mysql+pymysql`: Tells SQLAlchemy to use MySQL with the pymysql driver
  - `{MYSQL_USER}:{MYSQL_PASSWORD}`: Authentication credentials
  - `@{MYSQL_HOST}:{MYSQL_PORT}`: Server location
  - `/{MYSQL_DB}`: Which database to connect to

**Example URLs:**

- Local development: `mysql+pymysql://root:secret@localhost:3306/fastapi_db`
- Remote server: `mysql+pymysql://app_user:pass123@192.168.1.50:3306/production_db`

**Key difference from SQLite:**

- SQLite: `sqlite:///database.db` (file-based, no authentication)
- MySQL: `mysql+pymysql://user:pass@host:port/dbname` (server-based, requires authentication)

### Create the Database Engine

```python
engine = create_engine(mysql_url, echo=True)
```

**Line-by-line explanation:**

- `create_engine(mysql_url, echo=True)`: Create the connection engine
  - `mysql_url`: The connection string we built above
  - `echo=True`: Log all SQL queries to console (helpful for learning/debugging)
  - The engine manages a **connection pool** - it reuses connections efficiently
  - Multiple requests can use the same engine simultaneously

**Important MySQL-specific notes:**

- Unlike SQLite, MySQL is a **server** - it runs as a separate process
- The engine doesn't create the database - you must create it manually in MySQL first
- Connection pooling means the engine maintains several open connections for performance

### Create Table Function

```python
def create_db_and_tables() -> None:
    SQLModel.metadata.create_all(engine)
```

**Line-by-line explanation:**

- `def create_db_and_tables() -> None:`: Function to create all tables
  - `-> None`: Type hint indicating this function returns nothing
- `SQLModel.metadata.create_all(engine)`: Create tables in MySQL
  - Generates and executes `CREATE TABLE` statements
  - **Important**: This only creates tables, not the database itself
  - The database (`fastapi_db`) must already exist in MySQL

**What this function does:**

- Reads all classes with `SQLModel` and `table=True`
- Generates appropriate `CREATE TABLE` SQL for MySQL
- Executes the SQL statements
- Is idempotent - safe to run multiple times

---

## Step 2: FastAPI Application (`main.py`)

The FastAPI application is **identical** to the SQLite version! This shows the power of SQLModel/SQLAlchemy - the same code works with different databases.

```python
from contextlib import asynccontextmanager
from typing import List
from fastapi import FastAPI
from sqlmodel import Session, select
from database_setup import Item, create_db_and_tables, engine
```

**Line-by-line explanation:**

- Same imports as SQLite version
- `from database_setup import Item, create_db_and_tables, engine`:
  - Now these come from our MySQL-configured database_setup.py
  - The code doesn't need to know it's MySQL vs SQLite!

### Lifespan Context Manager

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    create_db_and_tables()
    yield
```

**Same as SQLite version:**

- Runs `create_db_and_tables()` on startup
- Creates tables in MySQL before handling requests
- `yield` keeps app running until shutdown

### Create FastAPI App

```python
app = FastAPI(lifespan=lifespan)
```

**Same as SQLite version:**

- Creates the app with lifespan management

### Create Item Endpoint

```python
@app.post("/items/", response_model=Item)
def create_item(item: Item):
    with Session(engine) as session:
        session.add(item)
        session.commit()
        session.refresh(item)
        return item
```

**Identical to SQLite version:**

- POST endpoint for creating items
- `with Session(engine)`: Creates MySQL session
- `session.add(item)`: Stage for insertion
- `session.commit()`: Execute INSERT query in MySQL
- `session.refresh(item)`: Load MySQL-generated id back

### Read Items Endpoint

```python
@app.get("/items/", response_model=List[Item])
def read_items():
    with Session(engine) as session:
        items = session.exec(select(Item)).all()
        return items
```

**Identical to SQLite version:**

- GET endpoint for retrieving all items
- `select(Item)`: Generate SELECT query
- Works the same way with MySQL

---

## Setting Up MySQL Database

Before running the application, you must create the database:

### Option 1: MySQL Command Line

```bash
mysql -u root -p
# Enter your password when prompted
```

```sql
CREATE DATABASE fastapi_db;
```

### Option 2: MySQL Workbench

1. Open MySQL Workbench
2. Connect to your server
3. Run: `CREATE DATABASE fastapi_db;`

---

## How to Run This Project

### 1. Install Dependencies

```bash
pip install fastapi uvicorn sqlmodel pymysql cryptography
```

### 2. Set Environment Variables (Optional)

**Windows (PowerShell):**

```powershell
$env:MYSQL_USER="root"
$env:MYSQL_PASSWORD="your_password"
$env:MYSQL_HOST="localhost"
$env:MYSQL_PORT="3306"
$env:MYSQL_DB="fastapi_db"
```

**Linux/Mac:**

```bash
export MYSQL_USER="root"
export MYSQL_PASSWORD="your_password"
export MYSQL_HOST="localhost"
export MYSQL_PORT="3306"
export MYSQL_DB="fastapi_db"
```

**Or create a `.env` file** (requires `python-dotenv`):

```
MYSQL_USER=root
MYSQL_PASSWORD=your_password
MYSQL_HOST=localhost
MYSQL_PORT=3306
MYSQL_DB=fastapi_db
```

### 3. Create the Database

```sql
CREATE DATABASE fastapi_db;
```

### 4. Start the Server

```bash
uvicorn main:app --reload
```

### 5. Test the API

- Interactive docs: `http://127.0.0.1:8000/docs`
- Create an item (POST to `/items/`):
  ```json
  {
    "name": "Mouse",
    "price": 25.99,
    "is_offer": true
  }
  ```
- Get all items (GET to `/items/`)

---

## Key Differences: SQLite vs MySQL

| Feature            | SQLite                      | MySQL                                           |
| ------------------ | --------------------------- | ----------------------------------------------- |
| **Storage**        | Single file (`database.db`) | Server with multiple databases                  |
| **URL Format**     | `sqlite:///database.db`     | `mysql+pymysql://user:pass@host:port/db`        |
| **Driver**         | Built-in                    | Requires `pymysql`                              |
| **Authentication** | None                        | Username/password required                      |
| **Concurrency**    | Limited (file locking)      | Excellent (server handles multiple connections) |
| **Setup**          | Zero config                 | Must install and configure MySQL server         |
| **Production**     | Not recommended             | Excellent for production                        |
| **FastAPI Code**   | **Identical!**              | **Identical!**                                  |

---

## Security Best Practices

1. **Never hardcode passwords** in your code

   ```python
   # BAD
   MYSQL_PASSWORD = "secret123"

   # GOOD
   MYSQL_PASSWORD = os.getenv("MYSQL_PASSWORD")
   ```

2. **Use dedicated database users** (not root)

   ```sql
   CREATE USER 'fastapi_user'@'localhost' IDENTIFIED BY 'strong_password';
   GRANT ALL PRIVILEGES ON fastapi_db.* TO 'fastapi_user'@'localhost';
   FLUSH PRIVILEGES;
   ```

3. **Use `.gitignore`** to exclude `.env` files

   ```
   .env
   *.db
   __pycache__/
   ```

4. **Use connection pooling** (already handled by SQLAlchemy engine)

---

## Troubleshooting

### Error: "Can't connect to MySQL server"

- Check MySQL is running: `sudo systemctl status mysql`
- Verify host/port: Is MySQL on localhost:3306?
- Check firewall settings

### Error: "Access denied for user"

- Wrong username or password
- Verify credentials: `mysql -u root -p`
- Check user permissions

### Error: "Unknown database 'fastapi_db'"

- Database doesn't exist
- Create it: `CREATE DATABASE fastapi_db;`

### Error: "No module named 'pymysql'"

- Install the driver: `pip install pymysql cryptography`

---

## Key Concepts Summary

1. **Environment Variables**: Keep sensitive configuration out of code
2. **Connection URL**: Different format for different databases
3. **Database Driver**: `pymysql` enables Python to talk to MySQL
4. **Database vs Tables**: MySQL database must exist; tables are auto-created
5. **Connection Pooling**: Engine efficiently manages multiple connections
6. **Database Abstraction**: Same FastAPI/SQLModel code works with any database!

## What Happens Behind the Scenes?

1. **App starts** → Reads environment variables → Builds MySQL connection URL → Creates engine
2. **Lifespan startup** → Connects to MySQL server → Creates tables if they don't exist
3. **POST request** → Opens MySQL session → Inserts row → MySQL generates auto-increment ID → Returns response
4. **GET request** → Opens MySQL session → Queries rows → Returns JSON list
5. **App stops** → Connection pool closes → Sessions cleaned up

This pattern is production-ready and scales to thousands of requests!
